# Висновки порівняння алгоритмів видачі решти

## Результати тестування

Для набору монет **[50, 25, 10, 5, 2, 1]** були протестовані суми: `113`, `999`, `1000`, `5000`, `10000` грн.

> **Жадібний алгоритм** та **динамічне програмування** дають однакову кількість монет для всіх тестованих сум.

## Робота з великими сумами

При збільшенні суми решти:
- **Жадібний алгоритм** зберігає постійну швидкість `O(n)`, де n - кількість номіналів
- **Динамічне програмування** сповільнюється пропорційно сумі `O(amount × n)`

⚡ Для суми **10000 грн** жадібний алгоритм працює приблизно в **5000 разів швидше**.

## Чому жадібний алгоритм ефективніший для цього випадку

1. **Канонічний набір монет** - кожна монета більшого номіналу може бути представлена через монети меншого номіналу без втрати оптимальності

2. **Простота обчислень** - жадібний алгоритм виконує тільки ділення та віднімання

3. **Мінімальне використання пам'яті** - не потребує додаткових масивів

## Коли динамічне програмування може бути кращим

Динамічне програмування стає необхідним при неканонічних наборах монет. Наприклад, для номіналів `[1, 3, 4]`:
- Сума 6: жадібний дає **3 монети** (4+1+1), оптимально - **2 монети** (3+3) 

## Підсумок

Для касового апарату з стандартними номіналами **[50, 25, 10, 5, 2, 1]** жадібний алгоритм є оптимальним вибором через високу швидкість та гарантовану оптимальність результату.